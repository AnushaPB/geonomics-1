#GEONOMICS_paramsfile_18-09-2018_14:12:29.py

#This is a default parameters file generated by Geonomics 
#(by the gnx.params.make_parameters_file() function).


                      # :: ::    :::            #      
                #:::   :::::    :::   ::    :: :: :::# 
             # ::::     ::           ::   ::::::::::::::#
           #::::::                       ::::::::: :::::: :#
         # :    :::                    :::    ::    :::::::::#
        #ggggg eeee ooo   n   n   ooo   m   m iiiii  cccc ssss#
       #g     e    o   o  nn  n  o   o  m   m   i   c     s    # 
       #g     eee o     o n n n o     o mm mm   i   c     sssss#
       #g ggg eee o     o n  nn o     o m m m   i   c         s#
       #g   g e    o   o  n   n  o   o  m   m   i   c        ss#
        #gggg  eeee ooo   n   n   ooo   m   m iiiii  cccc ssss#
         #  ::::::::        ::::::::::::  :       ::  ::   : #
           #  ::::              :::::::  ::     ::::::::  :#
             # :::               :::::: ::       ::::::  #
                #:                ::::                # 
                      #                         #      


params = {

##############
#### LAND ####
##############
    'land': {

    ##############
    #### main ####
    ##############
        'main': {
            'dim':                      (20,20),
                #x- and y-dimensionality of landscape
            'res':                      (1,1),
                #landscape resolution in x and y dimensions (for crosswalking with real-world
                #distances; defaults to meaningless (1,1), will be reset if GIS rasters are read in
            'ulc':                      (0,0),
                #upper-left corner of the landscape; defaults to meaningless (0,0), can be set
                #to alternative values for crosswalking with real-world data, and will be
                #reset if GIS rasters are read in
            'prj':                      None,
                #projection of the landscape; only applicable if layers are to
                #be read in from a raster file; defaults to None
            }, # <END> 'main'

    ################
    #### scapes ####
    ################
        'scapes': {

            0: {
                #scape number (this integer key should be incremented for each
                #successive scape)
        #######################
        #### scape 0: init ####
        #######################

                'init': {
                    #initiating parameters for this scape
                    'name':             'scape0',
                        #each scape can take a unique string name (e.g. 'scape0', '1994', 'mean_T')

                    'rand': {
                        #parameters for making a scape using interpolation from randomly located random values
                        'n_pts':                        500,
                            #number of random coordinates to be used in generating random landscapes
                                #(only needed if rand == True)
                        'interp_method':                'cubic'
                            # interpolation method (valid: 'linear', 'cubic', 'nearest')
                        },

                    } # <END> 'init'

                }, # <END> scape 0



    #### NOTE: Individual Scapes' sections can be copy-and-pasted (and
    #### assigned distinct keys and names), to create additional Scapes.


            } # <END> 'scapes'

        }, # <END> 'land'

###################
#### COMMUNITY ####
###################
    'comm': {

        'pops': {

            0  :   {
                #this integer key should be incremented for each successive population

            #####################
            #### pop 0: init ####
            #####################

                'init': {
                    'name': 'pop0',
                        #each pop can take a unique string name (e.g. 'pop0', 'south', 'C_fasciata')
                    'N':                200,
                        #starting population size
                    'K_scape_num':      0,
                        #the scape_num of the raster to use as the carrying-capacity raster (K)
                    'K_fact':           2
                        #the factor to multiply the K raster by in order to generate pop.K
                    }, # <END> 'init'

            #######################
            #### pop 0: mating ####
            #######################

                'mating'    : {
                    'repro_age':            0,
                        #age at sexual maturity (int or float for non-sexual species, tuple or list
                            #of two ints/floats for sexual species; set to 'None' to not make this
                            #an age-structured species
                    'max_age':              5,
                        #age beyond which all individuals will automatically die; default to None
                    'sex':                  False,
                        #is this a sexual species?
                    'dist_weighted_birth':  False,
                        #should the probability of birth be weighted by the distance between
                            #individuals in a pair?
                    'R':                    0.5,
                        #pop intrinsic growth rate
                    'b':                    0.2,
                        #population intrinsic birth rate (implemented as the probability
                            #that an identified potential mating pair successfully mates);
                            #NOTE: this may later need to be re-implemented to allow for spatial
                            #variation in intrinsic rate (e.g. expression as a raster) and/or for
                            #density-dependent births as well as deaths
                    'n_births_lambda':      4,
                        #expected value of offspring for a successful mating pair (used as the lambda value in a Poisson distribution)
                    'mating_radius':        1
                        #radius of mate-searching area
                    }, # <END> 'mating'

            ##########################
            #### pop 0: mortality ####
            ##########################

                'mortality'     : {
                    'n_deaths_sigma':           0.2,
                        #std for the normal distribution used to choose the r.v. of deaths
                            #per timestep (mean of this distribution is the overshoot,
                            #as calculated from pop.size and pop.census())
                    'selection':                True,
                        #should the population undergo natural selection?
                    'dens_dependent_fitness':   True,
                        #should fitness be density dependent? (note: helps to avoid subpopulation 'clumping')
                    'dens_grid_window_width':   None,
                        #with window-width used for the Density_Grid_Stack that calculates pop density
                            #(if set to None, defaults to the closest factor of the larger landscape
                            #dimension to 1/10th of that dimension)
                            #NOTE: will eventually default to an approximation of Wright's genetic neighborhood
                            #distance, based on the population's movement/dispersal parameters
                   'd_min':                     0.01,
                        #minimum neutral (i.e. non-selection driven) probability of death
                    'd_max':                    0.90,
                        #maximum neutral probability of death
 
                    }, # <END> 'mortality'

            #########################
            #### pop 0: movement ####
            #########################

                'movement': {
                   'move':          True,
                        #is this a mobile species?
                    'direction_mu':     0,
                        #mu for von mises distribution defining movement directions
                    'direction_kappa':  0,
                        #kappa for von mises distribution
                    'distance_mu':      0.5,
                        #mean movement-distance (lognormal distribution)
                    'distance_sigma':   0.5,
                        #sd of movement distance
                    'dispersal_mu':     0.5,
                        #mean dispersal distance (lognormal distribution)
                    'dispersal_sigma':  0.5,
                        #sd of dispersal distance

                    'move_surf'     : {
                        'make':                         True,
                            #use a landscape layer as a resistance surface, or habitat quality layer, to direct movement?
                        'scape_num':                    0,
                            #scape number to use as the movement surface
                        'approximation_len':            7500,
                            #length of the lookup vectors (numpy arrays) used to approximate
                                #the VonMises mixture distributions at each cell
                        'vm_kappa':                     None,
                            #kappa value to use in the von Mises mixture distributions (KDEs)
                                #underlying resistance surface movement
                        'gauss_KDE_bw':                 None
                            #bandwidth value to use in the Gaussian KDEs that are created to
                                #approximate the von Mises mixture distributions (KDEs)
                                #underlying resistance surface movement
                        } # <END> 'move_surf'

                    },    # <END> 'movement'



                    }, # <END> pop 0



    #### NOTE: Individual Populations' sections can be copy-and-pasted (and
    #### assigned distinct keys and names), to create additional Populations.


            }, # <END> 'pops'

        }, # <END> 'comm'

###############
#### MODEL ####
###############
    'model': {
        'time': {
            #parameters to control the number of burn-in and main timesteps to
            #run for each iterations
            'T':            12,
                #total model runtime (in timesteps)
            'burn_T':       30
                #minimum burn-in runtime (in timesteps; this is a mininimum because
                    #burn-in will run for at least this long but until
                    #stationarity detected, which will likely be longer)
            }, # <END> 'timesteps'

        'its': {
            #parameters to control how many iterations of the model to run,
            #and whether or not to randomize the land and/or community
            #objects in each model iteration
            'n_its': 1,
                #how many iterations of the model should be run?
            'rand_land':    False,
                #randomize the land for each new iteration?
            'rand_comm':    False,
                #randomize the community for each new iteration?
            'rand_burn':  False,
                #randomize the burn-in for each new iteration? (i.e. burn in
                #each time, or burn in once at creation and then use the same
                #burnt-in population for each iteration?)
            }, # <END> 'iterations'




        } # <END> 'model'

    } # <END> 'params'
