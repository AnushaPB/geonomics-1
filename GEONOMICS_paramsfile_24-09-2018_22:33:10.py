#GEONOMICS_paramsfile_24-09-2018_22:33:10.py

#This is a default parameters file generated by Geonomics 
#(by the gnx.params.make_parameters_file() function).


                      # :: ::    :::            #      
                #:::   :::::    :::   ::    :: :: :::# 
             # ::::     ::           ::   ::::::::::::::#
           #::::::                       ::::::::: :::::: :#
         # :    :::                    :::    ::    :::::::::#
        #ggggg eeee ooo   n   n   ooo   m   m iiiii  cccc ssss#
       #g     e    o   o  nn  n  o   o  m   m   i   c     s    # 
       #g     eee o     o n n n o     o mm mm   i   c     sssss#
       #g ggg eee o     o n  nn o     o m m m   i   c         s#
       #g   g e    o   o  n   n  o   o  m   m   i   c        ss#
        #gggg  eeee ooo   n   n   ooo   m   m iiiii  cccc ssss#
         #  ::::::::        ::::::::::::  :       ::  ::   : #
           #  ::::              :::::::  ::     ::::::::  :#
             # :::               :::::: ::       ::::::  #
                #:                ::::                # 
                      #                         #      


params = {

##############
#### LAND ####
##############
    'land': {

    ##############
    #### main ####
    ##############
        'main': {
            'dim':                      (20,20),
                #x- and y-dimensionality of landscape
            'res':                      (1,1),
                #landscape resolution in x and y dimensions (for crosswalking with real-world
                #distances; defaults to meaningless (1,1), will be reset if GIS rasters are read in
            'ulc':                      (0,0),
                #upper-left corner of the landscape; defaults to meaningless (0,0), can be set
                #to alternative values for crosswalking with real-world data, and will be
                #reset if GIS rasters are read in
            'prj':                      None,
                #projection of the landscape; only applicable if layers are to
                #be read in from a raster file; defaults to None
            }, # <END> 'main'

    ################
    #### scapes ####
    ################
        'scapes': {

            0: {
                #scape number (this integer key should be incremented for each
                #successive scape)
        #######################
        #### scape 0: init ####
        #######################

                'init': {
                    #initiating parameters for this scape
                    'name':             'scape0',
                        #each scape can take a unique string name (e.g. 'scape0', '1994', 'mean_T')

                    'nlmpy': {
                        #parameters for making an nlmpy scape (using any nlmpy
                        #function for which valid arguments are provided)
                        #NOTE: all other parameters in this dictionary will be
                        #unpacked as arguments to the nlmpy function chosen;
                        #thus, all necessary and only valid arguments must be
                        #provided or a general error will be thrown
                        'function':                 'mpd',
                            #filepath to read into this scape
                        'nRow':                     20,
                            #number of rows (must agree with land dimensions)
                        'nCol':                     20,
                            #number of columns (must agree with land
                            #dimensions)
                        'h':                        1,
                            #"controls the level of spatial autocorrelation
                            #in element values"
                        },

                    } # <END> 'init'

                }, # <END> scape 0



    #### NOTE: Individual Scapes' sections can be copy-and-pasted (and
    #### assigned distinct keys and names), to create additional Scapes.


            } # <END> 'scapes'

        }, # <END> 'land'

###################
#### COMMUNITY ####
###################
    'comm': {

        'pops': {

            0  :   {
                #this integer key should be incremented for each successive population

            #####################
            #### pop 0: init ####
            #####################

                'init': {
                    'name': 'pop0',
                        #each pop can take a unique string name (e.g. 'pop0', 'south', 'C_fasciata')
                    'N':                200,
                        #starting population size
                    'K_scape_num':      0,
                        #the scape_num of the raster to use as the carrying-capacity raster (K)
                    'K_fact':           2
                        #the factor to multiply the K raster by in order to generate pop.K
                    }, # <END> 'init'

            #######################
            #### pop 0: mating ####
            #######################

                'mating'    : {
                    'repro_age':            0,
                        #age at sexual maturity (int or float for non-sexual species, tuple or list
                            #of two ints/floats for sexual species; set to 'None' to not make this
                            #an age-structured species
                    'max_age':              5,
                        #age beyond which all individuals will automatically die; default to None
                    'sex':                  False,
                        #is this a sexual species?
                    'sex_ratio':            1/1,
                        #ratio of males to females
                    'dist_weighted_birth':  False,
                        #should the probability of birth be weighted by the distance between
                            #individuals in a pair?
                    'R':                    0.5,
                        #pop intrinsic growth rate
                    'b':                    0.2,
                        #population intrinsic birth rate (implemented as the probability
                            #that an identified potential mating pair successfully mates);
                            #NOTE: this may later need to be re-implemented to allow for spatial
                            #variation in intrinsic rate (e.g. expression as a raster) and/or for
                            #density-dependent births as well as deaths
                    'n_births_lambda':      4,
                        #expected value of offspring for a successful mating pair (used as the lambda value in a Poisson distribution)
                    'mating_radius':        1
                        #radius of mate-searching area
                    }, # <END> 'mating'

            ##########################
            #### pop 0: mortality ####
            ##########################

                'mortality'     : {
                    'n_deaths_sigma':           0.2,
                        #std for the normal distribution used to choose the r.v. of deaths
                            #per timestep (mean of this distribution is the overshoot,
                            #as calculated from pop.size and pop.census())
                    'selection':                True,
                        #should the population undergo natural selection?
                    'dens_dependent_fitness':   True,
                        #should fitness be density dependent? (note: helps to avoid subpopulation 'clumping')
                    'dens_grid_window_width':   None,
                        #with window-width used for the Density_Grid_Stack that calculates pop density
                            #(if set to None, defaults to the closest factor of the larger landscape
                            #dimension to 1/10th of that dimension)
                            #NOTE: will eventually default to an approximation of Wright's genetic neighborhood
                            #distance, based on the population's movement/dispersal parameters
                   'd_min':                     0.01,
                        #minimum neutral (i.e. non-selection driven) probability of death
                    'd_max':                    0.90,
                        #maximum neutral probability of death
 
                    }, # <END> 'mortality'

            #########################
            #### pop 0: movement ####
            #########################

                'movement': {
                   'move':          True,
                        #is this a mobile species?
                    'direction_mu':     0,
                        #mu for von mises distribution defining movement directions
                    'direction_kappa':  0,
                        #kappa for von mises distribution
                    'distance_mu':      0.5,
                        #mean movement-distance (lognormal distribution)
                    'distance_sigma':   0.5,
                        #sd of movement distance
                    'dispersal_mu':     0.5,
                        #mean dispersal distance (lognormal distribution)
                    'dispersal_sigma':  0.5,
                        #sd of dispersal distance

                    },    # <END> 'movement'


            #########################
            #### pop 0: gen_arch ####
            #########################

                'gen_arch': {
                    'L':                        10,
                        #total number of loci
                    'l_c':                      [10],
                        #chromosome lengths [sum(l_c) == L is enforced]
                    'gen_arch_file':            None,
                        #if not None, should point to a file stipulating a
                            #custom genomic architecture (i.e. a CSV with loci
                            #as rows and 'locus_num', 'p', 'r', 'trait', and
                            #'alpha' as columns, such as is created by
                            #main.make_params_file, when the custom_gen_arch
                            #arugment is True)
                    'mu_neut':                  1e-9,
                        #genome-wide neutral mutation rate, per base per generation
                            #(set to 0 to disable neutral mutation)
                    'mu_delet':                 1e-9,
                        #genome-wide deleterious mutation rate, per base per generation
                            #(set to 0 to disable deleterious mutation)
                            #NOTE: these mutations will fall outside the loci involved in any traits
                            #being simulated, and are simply treated as universally deleterious, with the same
                            #negative influence on fitness regardless of spatial context
                    'mut_log':                  False,
                        #whether or not to store a mutation log; if true, will be saved as mut_log.txt
                        #within each iteration's subdirectory
                    'shape_delet_s_dist':       0.2,
                    'scale_delet_s_dist':       0.2,
                        #mean and standard deviation of the per-allele effect size of deleterious mutations (std = 0 will fix all
                            #mutations for the mean value)
                    'alpha_r_dist':             0.5,
                        #alpha for beta distribution of linkage values
                            #NOTE: alpha = 14.999e9, beta = 15e9 has a VERY sharp peak on D = 0.4998333,
                            #with no values exceeding equalling or exceeding 0.5 in 10e6 draws in R
                    'beta_r_dist':              15e9,
                        #beta for beta distribution of linkage values
                    'use_dom':                  False,
                        #whether or not to use dominance (default to False)
                            #NOTE: REALLY JUST NEED TO GET RID OF THE DOMINANCE THING; IT'S ALL MESSED UP
                    'pleiotropy':               True,
                        #allow pleiotropy? (i.e. allow same locus to affect value of more than one trait?) false
                    'recomb_rate_custom_fn':    None,
                        #if provided, must be a function that returns a single recombination rate value (r) when called
                    'recomb_lookup_array_size': int(1e3),
                        #the size of the recombination-path lookup array to have
                            #read in at one time (needs to be comfortably larger than the anticipated totaly number of
                            #recombination paths to be drawn at once, i.e. than 2 times the anticipated most number of births at once)
                    'n_recomb_paths':           int(1e4),
                        #the total number of distinct recombination paths to
                            #generate at the outset, to approximate truly free recombination at the recombination rates specified
                            #by the genomic architecture (hence the larger the value the less the likelihood of mis-approximation artifacts)

                    }, # <END> 'gen_arch'


                    }, # <END> pop 0



    #### NOTE: Individual Populations' sections can be copy-and-pasted (and
    #### assigned distinct keys and names), to create additional Populations.


            }, # <END> 'pops'

        }, # <END> 'comm'

###############
#### MODEL ####
###############
    'model': {
        'time': {
            #parameters to control the number of burn-in and main timesteps to
            #run for each iterations
            'T':            12,
                #total model runtime (in timesteps)
            'burn_T':       30
                #minimum burn-in runtime (in timesteps; this is a mininimum because
                    #burn-in will run for at least this long but until
                    #stationarity detected, which will likely be longer)
            }, # <END> 'timesteps'

        'its': {
            #parameters to control how many iterations of the model to run,
            #and whether or not to randomize the land and/or community
            #objects in each model iteration
            'n_its': 1,
                #how many iterations of the model should be run?
            'rand_land':    False,
                #randomize the land for each new iteration?
            'rand_comm':    False,
                #randomize the community for each new iteration?
            'rand_burn':  False,
                #randomize the burn-in for each new iteration? (i.e. burn in
                #each time, or burn in once at creation and then use the same
                #burnt-in population for each iteration?)
            }, # <END> 'iterations'




        } # <END> 'model'

    } # <END> 'params'
