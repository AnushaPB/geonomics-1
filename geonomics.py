#!/usr/bin/python
# main.py

'''
##########################################

Module name:          main


Module contains:
                      - the Geonomics main module, containing the key,
                        highest-level functions the common user would need


Author:               Drew Ellison Hart
Email:                drew.hart@berkeley.edu
Github:               URL
Start date:           07-06-18
Documentation:        URL


##########################################
'''

#geonomics imports
from sim import model
from sim import params as par
from structs import landscape, genome, individual, population, community

#other imports
import re
import os, sys
from collections import Counter as C
import numpy as np
import pandas as pd

######################################
# -----------------------------------#
# CLASSES ---------------------------#
# -----------------------------------#
######################################


######################################
# -----------------------------------#
# FUNCTIONS -------------------------#
# -----------------------------------#
######################################

#wrapper around params.make_parameters_file
#TODO
def make_parameters_file(filepath=None, scapes=1, populations=1, data=None,
                         stats=None, seed=None):
    """
    Create a new parameters file.
    
    Write to disk a new, template parameters file. The file will contain the
    numbers and types of sections indicated by the parameters fed to this
    function. It will often be ready to be used 'out of the box' to make
    a new Model object, but typically it will be edited by the user to 
    stipulate the scenario being simulated prior to being instantiated as a
    Model.

    Parameters
    ----------
    filepath : str, optional
        Where to write the resulting parameters file, in /path/to/filename.py
        format. Defaults to None. If None, a file named 
        "GEONOMICS_params_<datetime>.py" will be written to the working
        directory.
    scapes : {int, list of dicts}, optional
        Number (and optionally, types) of Scape-parameter sections to include
        in the parameters file that is generated. Defaults to 1. Valid values
        and their associated behaviors are:

        int:
            Add sections for the stipulated number of Scapes, each with default
            settings:
                - parameters for creating Scapes of type 'random' (i.e.
                  Scapes that will be generated by interpolation from
                  randomly valued random points)
                - no ScapeChanger parameters
        [dict, ..., dict]:
            Each dict in this list should be of the form:
                {'type':    'random', 'defined', 'file', or 'nlmpy',
                'change':   bool 
                }
            This will add one section of Scape parameters, with the
            contents indicated, for each dict in this list.
    populations : {int, list of dicts}, optional
        Number (and optionally, types) of Population-parameter sections to
        include in the parameters file that is generated. Defaults to 1. Valid
        values and their associated behaviors are:

        int:
            Add sections for the stipulated number of Populations, each with
            default settings:
                - parameters for movement without a MovementSurface
                - parameters for a GenomicArchitecture with 0 Traits (i.e. with
                  only neutral loci)
                - no PopulationChanger parameters
        [dict, ..., dict]:
            Each dict should contain at least one argument from among the
            following:
                {'movement':                       bool,
                'movement_surface':                bool,
                'genomes':                         bool,
                'n_traits':                        int,
                'custom_genomic_architecture':     bool,
                'demographic_change':              int,
                'parameter_change':                bool
                }
            This will add one section of Population parameters, customized
            as indicated, for each dict in the list.

    data : bool, optional
        Whether to include a Data-parameter section in the parameters file that
        is generated. Defaults to None. Valid values and their associated
        behaviors are:

        None, False:
            Will not add a section for parameterizing data to be collected.
            No DataCollector will be created for the Model object made from
            the resulting parameters file, and no data will be collected
            during the model runs.
        True:
            Will add a section that can be used to parameterize which
            data will be collected during the model runs, when, and what
            file formats will be used to write it to disk.
            (This which will be managed by the model's DataCollector
            object.)

    stats : bool, optional 
        Whether to include a Stats-parameter section in the parameters file that
        is generated. Defaults to None. Valid values and their associated
        behaviors are:
        
        None, False:
            Will not add a section for parameterizing the statistics to be
            calculated. No StatsCollector will be created for the Model
            object made from the resulting parameters file, and no
            statistics will be calculated during the model runs.
        True:
            Will add a section that can be used to parameterize which
            statistics will be calculated during the model runs, and when.
            (This will be managed by the model's StatsCollector object.)

    seed : bool, optional
        Whether to include a seed-parameter section in the parameters file that
        is generated. Defaults to None. Valid values and their associated
        behaviors are:

        None, False:
            Will not add a section for parameterizing how the random number
            generators are seeded, hence generators will be seeded at
            random and results will be unreproducible.
        True:
            Will add a section for parameterizing how the random number
            generators are seeded, so that results will be reproducible.

    Returns
    -------
    Returns no output. Resulting parameters file will be written to the
    location and filename indicated (or by default, will be written to a file
    named "GEONOMICS_params_<datetime>.py" in the working directory).

    See Also
    --------
    sim.params.make_parameters_file

    Notes
    -----
    All parameters of this function are optional. Calling the function without
    providing any parameters will always produce the parameters file for the
    default model scenario. This file can be instantiated as a Model object and
    run without being edited. Those three steps (create default parameters file;
    create model from that parameters file; run the model) serve as a base case
    to test successful package installation, and are wrapped around by the
    convenience function `gnx.run_default_model`.

    Examples
    --------
    >>> #import geonomics
    >>> import geonomics as gnx
    >>> #create a parameters file for the default model
    >>> gnx.make_parameters_file()
    >>> #instantiate a model from that parameters file (assuming it is the only
    >>> #parameters file in the working directory, so will be succesfully
    >>> #identified by geonomics without user specification)
    >>> mod = gnx.make_model()
    >>> #run the resulting model (in verbose mode)
    >>> mod.run(verbose = True)
    >>>

    >>> #create a parameters file for a model scenario with 3 scapes, 1
    >>> #population, and data-collection
    >>> gnx.make_parameters_file(scapes = 3, data = True)
    >>>

    >>> #create a parameters file for a model scenario with 2 scapes (one being
    >>> #an nlmpy Scape that will not change over model time, the other being
    >>> #read in from a GIS raster file and being subject to change over model
    >>> #time); 2 populations (the first having a genomes, 2 Traits, and with
    >>> #movement being dictated by a MovementSurface; the second not having
    >>> #genomes, but having a MovementSurface as well, and undergoing
    >>> #demographic change over model time); also with data-collection, stats-
    >>> #collection, and a parameters section for setting the seed for the
    >>> #random-number generators; and saved to the file
    >>> #"2-pop_2-trait_model.py"
    >>> gnx.make_parameters_file(
    >>>     #list of 2 dicts containings the values for each scape-parameter
    >>>     #section to be included in the resulting parameters file
    >>>     scapes = [{'type': 'nlmpy'}, {'type': 'gis', 'change': True}],
    >>>     #list of 2 dicts containings the values for each population-
    >>>     #parameter section to be included in the resulting parameters file
    >>>     populations = [{'genomes': True, 'n_traits': 2, 
    >>>                     'movement': True, 'movement_surface': True},
    >>>         {'genomes': False, 'movement': True, 'movement_surface': True,
    >>>          'demographic_change': True}],
    >>>     #arguments to the data, stats,and seed parameters
    >>>     data = True, stats = True, seed = True,
    >>>     #destination to which to write the resulting parameter file
    >>>     filepath = '2-pop_2-trait_model.py')
    >>>

    """

    par.make_parameters_file(filepath = filepath, scapes = scapes,
                                populations = populations, data = data,
                                stats = stats, seed = seed)

#wrapper around params.read
def read_params(params_filepath):
    #first read in file as a block of text
    with open(params_filepath, 'r') as f:
        txt = f.read()
    #find all the scape names and pop names
    scape_names = re.findall('\S+(?= *\: *\{.*\n.*#scape name)', txt) 
    pop_names = re.findall('\S+(?= *\: *\{.*\n.*#pop name)', txt) 
    #get Counter objects of each
    scape_name_cts = C(scape_names)
    pop_name_cts = C(pop_names)
    #assert that each name is used only once
    assert set([*scape_name_cts.values()]) == {1}, ("At least one of the Scape "
        "names provided in the parameters file appears to be used more than "
        "once. Violating names include: %s") % (';'.join([("'%s', used %i "
            "times.") % (str(k), v) for k, v in scape_name_cts.items() if v>1]))
    assert set([*pop_name_cts.values()]) == {1}, ("At least one of the "
        "Population names provided in the parameters file appears to be used "
        "more than once. Violating names include: %s") % (';'.join([("'%s', "
            "used %i times.") % (
                str(k), v) for k, v in pop_name_cts.items() if v>1]))


    #regex to check that no scapes
    #or pops have identical names (i.e. keys)
    params = par.read(params_filepath)
    return(params)


#function to create a model from a ParametersDict object
def make_model(params=None):
    if params is None:
        try:
            params_files = [f for f in os.listdir('.') if (
                f.startswith('GEONOMICS_params') 
                and os.path.splitext(f)[1] == '.py')]
            assert len(params_files) == 1, ("The 'params' argument was not "
                "provided, and it appears that the current working directory "
                "contains more than one 'GEONOMICS_params_<...>.py' file. "
                "Please run again, providing a valid value for the 'params' "
                "argument.")
            params = params_files[0]
            print(("\n\nUsing the following file, in the current working "
                "directory to create the Model object:\n\t%s\n\n") % params)
        except Exception as e:
            raise ValueError(("The 'params' argument was not provided, and "
                "Geonomics could not identify a single "
                "'GEONOMICS_params_<...>.py' file in the current working "
                "directory from which to create the Model object. The "
                "following error was thrown: %s") % e)

    assert ( (type(params) is str and os.path.isfile(params))
        or str(type(params)) is "<class 'sim.params.ParametersDict'>"), ("If "
        "the 'params' argument is provided, its value must be either a string "
        "pointing to a valid Geonomics parameters file or an object of the "
        "ParametersDict class. If it is not provided, the current working "
        "directory must contain a single 'GEONOMICS_params_<...>.py' file "
        "from which to create the Model object.")

    if type(params) is str:
        try:
            params = read_params(params)
        except Exception as e:
            raise ValueError(("Failed to read the parameters file at the "
                "filepath that was provided. The following error was raised: "
                "\n\t%s\n\n") % e)
    elif str(type(params)) == "<class '__main__.Parameters_Dict'>":
        pass
    try:
        name = params.model.name
        mod = model.Model(name, params)
        return(mod)
    except Exception as e:
            raise ValueError(("Failed to create a Model object from the "
                "ParametersDict object that was provided. "
                "The following error was raised: \n\t%s\n\n") % e)

#convenience function for creating a parameters-file for, instantiating, and
#running the default model
def run_default_model():
    #get filenames before creating the default params file
    filenames = set(os.listdir('.'))
    #make the default params file
    make_parameters_file()
    #get filenames after creating the default params file
    new_filenames = set(os.listdir('.'))
    #take set-difference to get the new file (better than just calling
    #make_model without any arguments, since there's no guarantee that there
    #wasn't already a params file in this directory
    filename = [*new_filenames - filenames][0]
    #create the default model
    mod = make_model(params = filename)
    #run the default model in verbose mode
    mod.run(verbose = True)

#wrapper around landscape.make_land
def make_land(params):
    land = landscape.make_land(params)
    return land


#wrapper around genome.make_genomic_architecture
def make_genomic_architecture(params):
    gen_arch = genome.make_genomic_architecture(params)
    return gen_arch


#wrapper around individual.make_individual
    #should provide either a new genome for the individual, or a
    #genomic_architecture to use to draw its genome;
    #and should provide either a parental centerpoint to disperse from, or a
    #landscape.dim tuple within whihc to choose a location;
    #burn can be True (i.e. then the individual will have a [[0,0]] genome)
def make_individual(idx, genomic_architecture=None, new_genome=None, dim=None,
    parental_centerpoint=None, sex=None, age=0, burn=False):
    assert (genomic_architecture is not None
            or new_genome is not None), ("Either a new genome must be provided "
    "(i.e. 'new_genome' must not be None) or a genomic architecture from which "
    "to draw a new genome must be provided (i.e. 'genomic_architecture' must "
    "not be None.")
    assert (parental_centerpoint is not None
            or dim is not None), ("Either a landscape-dimension tuple must be "
            "provided (i.e. 'dim' must not be None) or a parental centerpoint "
            "from which to disperse the individual must be provided (i.e. "
            "'parental_centerpoint' must not be None).")
    ind = individual.make_individaul(idx = idx, offspring = False, 
            dim = dim, genomic_architecture = genomic_architecture,
            new_genome = new_genome, sex = sex, 
            parental_centerpoint = parental_centerpoint, age = age,
            burn = burn)
    return ind


#wrapper around population.make_population
    #burn can be True (i.e. then the individuals will have a [[0,0]] genome)
def make_population(land, pop_params, burn=False):
    pop = population.make_population(land, pop_params, burn = burn)
    return(pop)


#wrapper around community.make_comunity
    #burn can be True (i.e. then the individuals will have a [[0,0]] genome)
def make_community(land, params, burn=False):
    comm = community.make_community(land, params, burn = burn)
    return comm

