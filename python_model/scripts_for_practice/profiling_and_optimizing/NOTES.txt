#DEH: 05-01-18

Previously, I have been keeping notes in a combination of git commit messages, in-line or at top of
SCRATCH scripts, and also in my notebooks. But now I am really starting to make quicker progress profiling and
optimizing code (using mainly a combination of %timeit and %lprun, rather than that weird profiler
network-graph maker package that I used a while ago, which was not very useful in the end; see other files in
this directory from when I used that package). So it makese sense
to start keeping my notes in one file here.

As for the latest work:

The following indented block between hashed lines are the notes I originall had in
SCRATCH_optimize_movement_and_recomb_algs.py:

-------------------------------------------------------

  #########
  MOVEMENT:
  #########
  
  - check how r.choice(n) scales with length of n
  - check %lprof for both
  
  
  N         pop.move()   new_surf_move()  
  1000      139ms        4.35ms
  10000     1.41s        1.14s
  
  
  
  ANOTHER COMPARSION USING %timeit (USING MOVEMENT SURFACE APPROACHES BELOW AND COMPARING TO ORIGINAL):
  
  N               orig                    alt_movement_surf()         alt_alt_movement_surf()
  1000            214+-3.87 ms            9.28 ms +- 80.8 us          1.63 ms +- 36.5 us
  10000           1.08 s +- 11.2 ms       46.3 ms +- 727 us           7.97 ms +- 51.7 us
  
  AND COMPARING THE main() FN ON A DEMOGRAPHICALLY STABLE POP, USING THE SAME 3 DIFFERENT MOVE ALGS (A
  N~1000          1.45 s +- 58.9 ms       1.21 s +- 58.9 ms           1.27 s +- 71.1 ms
  
  
  Why should it seem to perform so much better on its own, but make less difference in the larger algorithm? I
  guess it IS just because movement is only a portion of the total runtime.A
  
  When I run the main() function with the three above algorithms and a pop ~1000 I get:
  
  
  orig                       alt_movement_surf()         alt_alt_movement_surf()
  7.683 s total time         6.006 s total time          5.801 s total time 
  movement is 28.3% of time  movement is 1.3% of time    movement is 0.4% of time
  
  ##############
  RECOMBINATION:
  ##############
  
  Maybe iteratively convert and store chunks of the total recombination approx array as bits!?! then just return
  a random bit from each inter-locus position
  
  
  - read about and play with int types for vector of binomial-draw approx in numpy, for recombination
  
  
  

-------------------------------------------------------

Replacing demography.calc_pop_density used in getting N_b raster with land.density_grid_stack.calc_density has
cut the runtime of demography.pop_dynamics basically in half (e.g. a pop of N~1000 ran 2.3 s old way vs 1.2 s
new way), reducing split of run-time percentages of movement and pop_dynamics in a main() function from
25%/75% to ~50%/50%, and reducing % of runtime of demography.pop_dynamics() used by n_pairs = ... from ~62.2%
to ~ 1.9%. Now, however, the N_b, N_d, and thus d rasters all have a much wider spread of high values around
population clusters where mating pairs occur (because this is dictated by the window_width of
land.density_grid_stack, whereas before the window_width was being set to match dispersal kernel radius, which
made for extreme lags); you can see this by running the old and new versions of demography.pop_dynamics in
debug mode and comparing the output arrays of rasters. I should now figure out how to attend to this, either
a.) by creating a second density_grid at the beginning of the model, which would also inhere to the
Landscape_Stack and with window_widths based on mu_dispersal, or b.) by coming up with some simpler way of
interpolating the surface??

Also, now 13.0% of runtime of demography.pop_dynamics is spent on pairs = pop.find_mating_pairs(...), which
hopefully will be reduced if Jiazheng and Irene's mating_grid approach works out, but which should also
separately be checked for potential speed gains; 10.5% is spent on the dNdt[K<1] = ... line (which can likely
be sped up easily with a bit of introspection), since a lot of this code was hacked together last spring just
to make the model work for my popgen class project; 50.5% of runtime is spent on pop.mate(), which I suspect
is largely consumed by recombination but which needs to be properly introspected and
optimized; 12.1% is spent on the d_ind = selection.get_prob_death(...) line, which I suspect could also be
optimized fairly easily; and 3.6% is spent on num_deaths = ..., which is a small fraction of time but which
could also likely be sped up a bit at minimal labor cost. 4.9% also spent on pop.calc_density, but I've
already put a ton of time into optimizing this, so probably no easily won gains there for the moment...

[pushed a commit]

Realized that phenotypes are being calculted each step, and this is hugely unnecessary, so I will
create an Individual.phenotype attribute and a set_phenotype() method that is called each time an individual
is created. So I needed to do:
  - create the attribute
  - create the method that calls selection.get_phenotype()
  - create a pop.get_phenotype() attribute like pop.get_x_coords(), etc.
  - in selection.get_fitness, change it from calling get_phenotype to just using the individuals' phenotype
    attributes
  - when genomes are reassigned in main() fn phenotypes need to also be reassigned


Also added an individual.idx attribute

Then implemented the new movement algorithm. (Note that building the movement_surf object now takes a buttload
of time for a reasonalbe length (I'm guessing roughly 5000?) of the VonMises approximation vectors, but
params.py provides a 'movement_surf_approx_len' entry which can be set to something low to allow for quick pop
creation when iteratively launching and running interactive processes while writing/debugging/optimizing
code.)

After all those changes, runtime per timestep for the main() function, with a pop ~1300, is down to 530 ms! :)

And now demography.pop_dynamics uses 96.4% of runtime of a single step of the main() fn, because movement is
much faster. And of that algorithm ~10.8% runtime is on the dNdt[K<1] line, ~58.3% on pop.mate, ~9.7% on d_ind
= selection.get_prob_death, And in pop.mate(), ~22.3% spent on recombinants = gametogenesis(...), ~34.1% 
on new_genomes = mating.mate(...),
~14.1% on self.individs[offspring_key].set_phenotype(...).  So those 
look like the most promising next 3 places to work on speeding things up.

Also, I should still run some more checks to ensure that the new movement functionality is working correctly (it was
in the SCRATCH script, but I of course had to tweak a bunch of things when I incorporated it). But I did run a
main() function for 50+ timesteps, then check pop.show_single_trait_fitness() for the monogenic trait, and
everything looked very good (basically, exactly as it did after roughly that many timesteps before I implemented the new movement algorithm.


And I should also think more about how to attend to the now-changed N_b, N_d, and d rasters (see notes above,
~line 16).

[pushed a commit]




#DEH 05-23-18:
Timing-trial results for new recombination approach:

  NEW APPROACH (on branch new_recomb_trial):
    N_start = 1250 individuals
    N_end = 1533
    n_timesteps = 200
    recomb_queue = len 5000, len_min 1000
    bitarray = len 100000, len_min 1000000 (??? LOOK INTO THIS)
    total elapsed time = 133.33883 seconds
    avg time/step = 0.667 seconds

  OLD APPROACH (on branch master):
    N_start = 1250 individuals
    N_end = 1498 
    n_timesteps = 200
    recomb_queue = n/a
    bitarray = n/a
    total elapsed time = 106.3258 s
    avg time/step = 0.532 s
